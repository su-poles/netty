一、Netty的异步模型
  1. Netty的I/O操作是异步的，当调用bind、Write、Connect等操作时，会简单的返回一个ChannelFuture
  2. 调用者不能立即获得结果，而是通过Future-Listener机制，通过主动获取或者通知机制得到操作结果
  3. Netty的异步模型是简历在future和callback之上的。callback就是回调。
      Future的核心思想：假设一个方法fun, 执行非常耗时，那么可以使用该机制，当调用fun时，立马返回一个Future, 后续可以通过Future去监控
      方法fun的处理过程。


二、Future-Listener机制

   1. 当Future对象刚刚穿见识，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操作。
   2. 常见操作有：
     （1）isDone              判断当前操作是否完成
     （2）isSuccess           判断已完成的当前操作是否成功
     （3）getCause            获取已完成的当前操作失败的原因
     （4）isCancelled         判断已完成的当期那操作是否被取消
     （5）addListener         通过该方法注册监听器，当操作 isDone 或 Future 对象已完成，则通知指定的监听器。


三、Channel
    （1）ChannelFuture future = serverBootstrap.bind(8080).sync();
        future.channel().getXXX()   这里可以获取很多的网络连接配置参数以及状态

    （2）Channel提供异步的网络I/O操作（如建立连接、读写、绑定端口），异步调用意味着任何I/O调用都将立即返回，并且不保证在调用结束时，所有
    请求的I/O操作已经完成

    （3）调用立即返回一个ChannelFuture示例，通过注册监听器到ChannelFuture上，可以I/O操作成功、失败或者取消时回调调用方

    （4）支持关联I/O操作与对应的处理程序

    （5）不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型：

        NioSocketChannel: 异步的客户端TCP Socket连接
        NioServerSocketChannel: 异步的服务器端TCP Socket连接
        NioDatagramChannel: 异步的UDP连接
        NioSctpChannel: 异步的客户端Sctp连接
        NioSctpServerChannel: 异步的Sctp服务器端连接，这些通道涵盖了 UDP 和 TCP 网络IO 以及 文件IO

四、Selector

    （1）Netty基于Selector对象实现I/O多路复用，通过Selector一个线程，可以监听多个连接的Channel事件
    （2）当向一个Selector中注册Channel后，Selector内部的机制就可以自动不断的查询（select）这些注册的Channel是否有自己就绪的I/O事件，
    例如可读、可写、网络连接完成等事件，这样程序就可以很简单的使用一个线程更高效的管理多个Channel